#ifndef WORLD_TERRAINNODE_H
#define WORLD_TERRAINNODE_H

#include "world/core/WorldConfig.h"

#include <utility>
#include <functional>
#include <set>
#include <typeinfo>

#include "world/core/TileSystem.h"
#include "world/flat/IGround.h"
#include "Terrain.h"
#include "ITerrainWorker.h"

namespace world {

class PGround;

class HeightmapGroundTile : public TerrainTile, public IGridElement {
public:
    HeightmapGroundTile(TileCoordinates coords, int terrainRes)
            : TerrainTile(coords, terrainRes) {}

    void saveTo(NodeCache &cache) const override {
        cache.saveTerrain("terrain", _terrain);
        // TODO texture, mesh
    }

    bool tryLoadFrom(const NodeCache &cache) override {
        return cache.readTerrainInplace("terrain", _terrain);
    }

private:
    vec2d _zBounds;

    friend class HeightmapGround;
};

/** This class manages an infinite ground with as much details
 * as we want. */
class WORLDAPI_EXPORT HeightmapGround : public GroundNode {
    WORLD_WRITE_SUBCLASS_METHOD
public:
    using Tile = HeightmapGroundTile;

    explicit HeightmapGround(double unitSize = 6000, double minAltitude = -2000,
                             double maxAltitude = 4000);

    ~HeightmapGround() override;

    // PARAMETERS
    // TODO constraints
    void setMaxAltitude(double max) { _maxAltitude = max; }

    void setMinAltitude(double min) { _minAltitude = min; }

    double getMaxAltitude() const { return _maxAltitude; }

    double getMinAltitude() const { return _minAltitude; }

    double getAltitudeRange() const { return _maxAltitude - _minAltitude; }

    void setTerrainResolution(int terrainRes) { _terrainRes = terrainRes; }

    void setTextureRes(int textureRes) {
        _textureRes = textureRes;
        _tileSystem._bufferRes.x = _tileSystem._bufferRes.y =
            _textureRes * _texPixSize;
    }

    void setMaxLOD(int lod) { _tileSystem._maxLod = lod; }

    /** Returns an atmospheric provider if there is any. */
    // This method is used in a bad hack that should not be required
    // anymore when we will be able to serialize references (should
    // come right after Unity terrains).
    IAtmosphericProvider *getAtmosphericProvider();

    // TERRAIN WORKERS
    /** Adds a default worker set to generate heightmaps in the
     * ground. This method is for quick-setup purpose. */
    void setDefaultWorkerSet();

    /** Creates and adds an ITerrainWorker to the Ground. The
     * ITerrainWorkers belong to the core of the generation process.
     * Each part of the ground is generated by a chain of worker,
     * each of which adds one feature after the other to the terrain.
     * */
    template <typename T, typename... Args> T &addWorker(Args &&... args);

    /** Get the first ITerrainWorker found with the required type.
     * If no ITerrainWorker is found with the correct type, an
     * exception is thrown. */
    template <typename T> T &getWorker();

    void setLodRange(const ITerrainWorker &worker, int minLod, int maxLod);

    // EXPLORATION
    double observeAltitudeAt(double x, double y, double resolution,
                             const ExplorationContext &ctx) override;

    void collect(ICollector &collector, const IResolutionModel &resolutionModel,
                 const ExplorationContext &ctx) override;

    void paintTexture(const vec2d &origin, const vec2d &size,
                      const vec2d &resolutionRange, const Image &img,
                      const ExplorationContext &ctx) override;

    // IO
    void write(WorldFile &wf) const override;

    void read(const WorldFile &wf) override;

private:
    PGround *_internal;

    // Parameters
    /** World lowest possible altitude. Sea level is 0. */
    double _minAltitude;
    /** World highest possible altitude. Sea level is 0. */
    double _maxAltitude;

    int _terrainRes = 33;
    int _textureRes = 128;
    /** The wanted "size" of a texture pixel in the final picture. Ideally 1,
     * set it to more if you need performances. */
    int _texPixSize = 4;

    TileSystem _tileSystem;

    // WORKER
    void addWorkerInternal(ITerrainWorker *worker);

    ITerrainWorker *getWorkerInternal(const std::type_info &type);

    double observeAltitudeAt(double x, double y, int lvl,
                             const ExplorationContext &ctx);

    void addTerrain(const TileCoordinates &key, ICollector &collector,
                    const ExplorationContext &ctx);


    // ACCESS
    HeightmapGround::Tile &provide(const TileCoordinates &key,
                                   const ExplorationContext &ctx);

    Terrain &provideTerrain(const TileCoordinates &key,
                            const ExplorationContext &ctx);

    Mesh &provideMesh(const TileCoordinates &key,
                      const ExplorationContext &ctx);

    bool isGenerated(const TileCoordinates &key);


    // DATA
    /** Gets a unique string id for the given tile in the Ground. */
    std::string getTerrainDataId(const TileCoordinates &key) const;


    // GENERATION
    void addNotGeneratedParents(std::set<TileCoordinates> &keys);

    /** Generate the terrains located at all the keys given in parameters.
     * Assume the terrains are not generated nor cached (this should be
     * verified before). */
    void generateTerrains(const std::set<TileCoordinates> &keys,
                          const ExplorationContext &ctx);

    void generateMesh(const TileCoordinates &key,
                      const ExplorationContext &ctx);

    friend class PGround;
    friend class GroundContext;
};

template <typename T, typename... Args>
T &HeightmapGround::addWorker(Args &&... args) {
    T *worker = new T(args...);
    addWorkerInternal(worker);
    return *worker;
};

template <typename T> T &HeightmapGround::getWorker() {
    auto *worker = getWorkerInternal(typeid(T));
    if (worker != nullptr) {
        return dynamic_cast<T &>(*worker);
    } else
        throw std::runtime_error("Bad ground worker type");
}
} // namespace world

#endif // WORLD_TERRAINNODE_H
